{"version":3,"sources":["useLinking.tsx"],"names":["React","getStateFromPath","getStateFromPathDefault","getPathFromState","getPathFromStateDefault","getActionFromState","ServerContext","getStateLength","state","length","history","index","focusedState","routes","stale","isUsingLinking","useLinking","ref","enabled","config","useEffect","Error","join","trim","enabledRef","useRef","configRef","getStateFromPathRef","getPathFromStateRef","current","server","useContext","getInitialState","useCallback","value","location","window","undefined","path","pathname","search","thenable","then","onfulfilled","Promise","resolve","catch","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","onPopState","navigation","previousHistoryIndex","historyIndex","getRootState","canGoBack","numberOfBacks","replaceState","i","goBack","action","dispatch","resetRoot","addEventListener","removeEventListener","unsubscribe","addListener","previousStateLength","stateLength","l","pushState","delta","Math","min","go"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport ServerContext from './ServerContext';\nimport { LinkingOptions } from './types';\n\ntype ResultState = ReturnType<typeof getStateFromPathDefault>;\n\ntype HistoryState = { index: number };\n\ndeclare const history: {\n  state?: HistoryState;\n  go(delta: number): void;\n  pushState(state: HistoryState, title: string, url: string): void;\n  replaceState(state: HistoryState, title: string, url: string): void;\n};\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    enabled = true,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(\n        [\n          'Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:',\n          \"- You are not using both 'linking' prop and 'useLinking'\",\n          \"- You don't have 'useLinking' in multiple components\",\n        ]\n          .join('\\n')\n          .trim()\n      );\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const enabledRef = React.useRef(enabled);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, enabled, getPathFromState, getStateFromPath]);\n\n  const server = React.useContext(ServerContext);\n\n  const getInitialState = React.useCallback(() => {\n    let value: ResultState | undefined;\n\n    if (enabledRef.current) {\n      const location =\n        server?.location ??\n        (typeof window !== 'undefined' ? window.location : undefined);\n\n      const path = location ? location.pathname + location.search : undefined;\n\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n\n    // Make it a thenable to keep consistent with the native impl\n    const thenable = {\n      then(onfulfilled?: (state: ResultState | undefined) => void) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch() {\n        return thenable;\n      },\n    };\n\n    return thenable as PromiseLike<ResultState | undefined>;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    const onPopState = () => {\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    };\n\n    window.addEventListener('popstate', onPopState);\n\n    return () => window.removeEventListener('popstate', onPopState);\n  }, [enabled, ref]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new entries were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new entries were added, pushState until we have same length\n        // This won't be accurate if multiple entries were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = Math.min(\n          previousStateLength - stateLength,\n          // We need to keep at least one item in the history\n          // Otherwise we'll exit the page\n          previousHistoryIndexRef.current - 1\n        );\n\n        if (delta > 0) {\n          // We need to set this to ignore the `popstate` event\n          pendingIndexChangeRef.current = index - delta;\n\n          // If new entries were removed, go back so that we have same length\n          history.go(-delta);\n        } else {\n          // We're not going back in history, but the navigation state changed\n          // The URL probably also changed, so we need to re-sync the URL\n          if (location.pathname + location.search !== path) {\n            history.replaceState({ index }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]}