{"version":3,"sources":["useLinking.tsx"],"names":["getStateLength","state","length","history","index","focusedState","routes","stale","isUsingLinking","useLinking","ref","enabled","config","getStateFromPath","getStateFromPathDefault","getPathFromState","getPathFromStateDefault","React","useEffect","Error","join","trim","enabledRef","useRef","configRef","getStateFromPathRef","getPathFromStateRef","current","server","useContext","ServerContext","getInitialState","useCallback","value","location","window","undefined","path","pathname","search","thenable","then","onfulfilled","Promise","resolve","catch","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","onPopState","navigation","previousHistoryIndex","historyIndex","getRootState","canGoBack","numberOfBacks","replaceState","i","goBack","action","dispatch","resetRoot","addEventListener","removeEventListener","unsubscribe","addListener","previousStateLength","stateLength","l","pushState","delta","Math","min","go"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport ServerContext from './ServerContext';\nimport { LinkingOptions } from './types';\n\ntype ResultState = ReturnType<typeof getStateFromPathDefault>;\n\ntype HistoryState = { index: number };\n\ndeclare const history: {\n  state?: HistoryState;\n  go(delta: number): void;\n  pushState(state: HistoryState, title: string, url: string): void;\n  replaceState(state: HistoryState, title: string, url: string): void;\n};\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    enabled = true,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(\n        [\n          'Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:',\n          \"- You are not using both 'linking' prop and 'useLinking'\",\n          \"- You don't have 'useLinking' in multiple components\",\n        ]\n          .join('\\n')\n          .trim()\n      );\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const enabledRef = React.useRef(enabled);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, enabled, getPathFromState, getStateFromPath]);\n\n  const server = React.useContext(ServerContext);\n\n  const getInitialState = React.useCallback(() => {\n    let value: ResultState | undefined;\n\n    if (enabledRef.current) {\n      const location =\n        server?.location ??\n        (typeof window !== 'undefined' ? window.location : undefined);\n\n      const path = location ? location.pathname + location.search : undefined;\n\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n\n    // Make it a thenable to keep consistent with the native impl\n    const thenable = {\n      then(onfulfilled?: (state: ResultState | undefined) => void) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch() {\n        return thenable;\n      },\n    };\n\n    return thenable as PromiseLike<ResultState | undefined>;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    const onPopState = () => {\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    };\n\n    window.addEventListener('popstate', onPopState);\n\n    return () => window.removeEventListener('popstate', onPopState);\n  }, [enabled, ref]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new entries were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new entries were added, pushState until we have same length\n        // This won't be accurate if multiple entries were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = Math.min(\n          previousStateLength - stateLength,\n          // We need to keep at least one item in the history\n          // Otherwise we'll exit the page\n          previousHistoryIndexRef.current - 1\n        );\n\n        if (delta > 0) {\n          // We need to set this to ignore the `popstate` event\n          pendingIndexChangeRef.current = index - delta;\n\n          // If new entries were removed, go back so that we have same length\n          history.go(-delta);\n        } else {\n          // We're not going back in history, but the navigation state changed\n          // The URL probably also changed, so we need to re-sync the URL\n          if (location.pathname + location.search !== path) {\n            history.replaceState({ index }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]}