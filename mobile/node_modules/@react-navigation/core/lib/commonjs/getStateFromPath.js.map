{"version":3,"sources":["getStateFromPath.tsx"],"names":["getStateFromPath","path","options","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","sort","a","b","pattern","split","length","remaining","replace","endsWith","match","find","config","routeNames","every","name","c","screen","createNestedStateObject","i","self","params","parseQueryParams","parse","undefined","result","current","allParams","regex","paramPatterns","filter","p","startsWith","reduce","acc","value","segments","decodeURIComponent","shift","join","state","routes","index","route","findFocusedRoute","findParseConfigForRoute","joinPaths","paths","Boolean","routeConfig","initials","parentPattern","push","createConfigItem","exact","screens","initialRouteName","connectedRoutes","forEach","nestedConfig","pop","RegExp","it","routeName","flatConfig","findInitialRoute","includes","createStateObject","initialRoute","isEmpty","nestedState","nestedStateIndex","parseConfig","query","queryString"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;;;;AAmBe,SAASA,gBAAT,CACbC,IADa,EAEbC,OAAmB,GAAG,EAFT,EAGY;AACzB,MAAIC,aAAmC,GAAG,EAA1C,CADyB,CAGzB;;AACA,QAAMC,OAAO,GAAI,EAAD,CACbC,MADa,CAEZ,GAAGC,MAAM,CAACC,IAAP,CAAYL,OAAZ,EAAqBM,GAArB,CAA0BC,GAAD,IAC1BC,uBAAuB,CAACD,GAAD,EAAMP,OAAN,EAAe,EAAf,EAAmBC,aAAnB,CADtB,CAFS,EAMbQ,IANa,CAOZ,CAACC,CAAD,EAAIC,CAAJ,KACE;AACAA,EAAAA,CAAC,CAACC,OAAF,CAAUC,KAAV,CAAgB,GAAhB,EAAqBC,MAArB,GAA8BJ,CAAC,CAACE,OAAF,CAAUC,KAAV,CAAgB,GAAhB,EAAqBC,MATzC,CAAhB;AAYA,MAAIC,SAAS,GAAGhB,IAAI,CACjBiB,OADa,CACL,MADK,EACG,GADH,EACQ;AADR,GAEbA,OAFa,CAEL,KAFK,EAEE,EAFF,EAEM;AAFN,GAGbA,OAHa,CAGL,OAHK,EAGI,EAHJ,CAAhB,CAhByB,CAmBA;AAEzB;;AACAD,EAAAA,SAAS,GAAGA,SAAS,CAACE,QAAV,CAAmB,GAAnB,IAA0BF,SAA1B,aAAyCA,SAAzC,MAAZ;;AAEA,MAAIA,SAAS,KAAK,GAAlB,EAAuB;AACrB;AACA;AACA,UAAMG,KAAK,GAAGhB,OAAO,CAACiB,IAAR,CACXC,MAAD,IACEA,MAAM,CAACrB,IAAP,KAAgB,EAAhB,IACAqB,MAAM,CAACC,UAAP,CAAkBC,KAAlB,EACE;AACCC,IAAAA,IAAD;AAAA;;AAAA,aAAU,mBAACrB,OAAO,CAACiB,IAAR,CAAcK,CAAD,IAAOA,CAAC,CAACC,MAAF,KAAaF,IAAjC,CAAD,kDAAC,cAAwCxB,IAAzC,CAAV;AAAA,KAFF,CAHU,CAAd;;AASA,QAAImB,KAAJ,EAAW;AACT,aAAOQ,uBAAuB,CAC5BR,KAAK,CAACG,UAAN,CAAiBf,GAAjB,CAAqB,CAACiB,IAAD,EAAOI,CAAP,EAAUC,IAAV,KAAmB;AACtC,YAAID,CAAC,KAAKC,IAAI,CAACd,MAAL,GAAc,CAAxB,EAA2B;AACzB,iBAAO;AAAES,YAAAA,IAAF;AAAQM,YAAAA,MAAM,EAAEC,gBAAgB,CAAC/B,IAAD,EAAOmB,KAAK,CAACa,KAAb;AAAhC,WAAP;AACD;;AAED,eAAO;AAAER,UAAAA;AAAF,SAAP;AACD,OAND,CAD4B,EAQ5BtB,aAR4B,CAA9B;AAUD;;AAED,WAAO+B,SAAP;AACD;;AAED,MAAIC,MAAJ;AACA,MAAIC,OAAJ;;AAEA,SAAOnB,SAAP,EAAkB;AAChB,QAAIM,UAAJ;AACA,QAAIc,SAAJ,CAFgB,CAIhB;;AACA,SAAK,MAAMf,MAAX,IAAqBlB,OAArB,EAA8B;AAC5B,UAAI,CAACkB,MAAM,CAACgB,KAAZ,EAAmB;AACjB;AACD;;AAED,YAAMlB,KAAK,GAAGH,SAAS,CAACG,KAAV,CAAgBE,MAAM,CAACgB,KAAvB,CAAd,CAL4B,CAO5B;;AACA,UAAIlB,KAAJ,EAAW;AACTG,QAAAA,UAAU,GAAG,CAAC,GAAGD,MAAM,CAACC,UAAX,CAAb;AAEA,cAAMgB,aAAa,GAAGjB,MAAM,CAACR,OAAP,CACnBC,KADmB,CACb,GADa,EAEnByB,MAFmB,CAEXC,CAAD,IAAOA,CAAC,CAACC,UAAF,CAAa,GAAb,CAFK,CAAtB;;AAIA,YAAIH,aAAa,CAACvB,MAAlB,EAA0B;AACxBqB,UAAAA,SAAS,GAAGE,aAAa,CAACI,MAAd,CAA0C,CAACC,GAAD,EAAMH,CAAN,EAASZ,CAAT,KAAe;AACnE,kBAAMgB,KAAK,GAAGzB,KAAK,CAAE,CAACS,CAAC,GAAG,CAAL,IAAU,CAAZ,CAAL,CAAoBX,OAApB,CAA4B,IAA5B,EAAkC,EAAlC,CAAd,CADmE,CACd;;AAErD0B,YAAAA,GAAG,CAACH,CAAD,CAAH,GAASI,KAAT;AAEA,mBAAOD,GAAP;AACD,WANW,EAMT,EANS,CAAZ;AAOD;;AAED3B,QAAAA,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkBE,KAAK,CAAC,CAAD,CAAvB,EAA4B,EAA5B,CAAZ;AAEA;AACD;AACF,KAlCe,CAoChB;;;AACA,QAAIG,UAAU,KAAKW,SAAnB,EAA8B;AAC5B,YAAMY,QAAQ,GAAG7B,SAAS,CAACF,KAAV,CAAgB,GAAhB,CAAjB;AAEAQ,MAAAA,UAAU,GAAG,CAACwB,kBAAkB,CAACD,QAAQ,CAAC,CAAD,CAAT,CAAnB,CAAb;AACAA,MAAAA,QAAQ,CAACE,KAAT;AACA/B,MAAAA,SAAS,GAAG6B,QAAQ,CAACG,IAAT,CAAc,GAAd,CAAZ;AACD;;AAED,UAAMC,KAAK,GAAGtB,uBAAuB,CACnCL,UAAU,CAACf,GAAX,CAAgBiB,IAAD,IAAU;AACvB,YAAMH,MAAM,GAAGlB,OAAO,CAACiB,IAAR,CAAcK,CAAD,IAAOA,CAAC,CAACC,MAAF,KAAaF,IAAjC,CAAf;AAEA,UAAIM,MAAJ;;AAEA,UAAIM,SAAS,KAAIf,MAAJ,aAAIA,MAAJ,uBAAIA,MAAM,CAAErB,IAAZ,CAAb,EAA+B;AAC7B,cAAMa,OAAO,GAAGQ,MAAM,CAACrB,IAAvB;;AAEA,YAAIa,OAAJ,EAAa;AACX,gBAAMyB,aAAa,GAAGzB,OAAO,CAC1BC,KADmB,CACb,GADa,EAEnByB,MAFmB,CAEXC,CAAD,IAAOA,CAAC,CAACC,UAAF,CAAa,GAAb,CAFK,CAAtB;;AAIA,cAAIH,aAAa,CAACvB,MAAlB,EAA0B;AACxBe,YAAAA,MAAM,GAAGQ,aAAa,CAACI,MAAd,CAA0C,CAACC,GAAD,EAAMH,CAAN,KAAY;AAC7D,oBAAMhC,GAAG,GAAGgC,CAAC,CAACvB,OAAF,CAAU,IAAV,EAAgB,EAAhB,EAAoBA,OAApB,CAA4B,KAA5B,EAAmC,EAAnC,CAAZ;AACA,oBAAM2B,KAAK,GAAGR,SAAS,CAAEI,CAAF,CAAvB;;AAEA,kBAAII,KAAJ,EAAW;AACTD,gBAAAA,GAAG,CAACnC,GAAD,CAAH,GACEa,MAAM,CAACW,KAAP,IAAgBX,MAAM,CAACW,KAAP,CAAaxB,GAAb,CAAhB,GACIa,MAAM,CAACW,KAAP,CAAaxB,GAAb,EAAkBoC,KAAlB,CADJ,GAEIA,KAHN;AAID;;AAED,qBAAOD,GAAP;AACD,aAZQ,EAYN,EAZM,CAAT;AAaD;AACF;AACF;;AAED,UAAIb,MAAM,IAAIzB,MAAM,CAACC,IAAP,CAAYwB,MAAZ,EAAoBf,MAAlC,EAA0C;AACxC,eAAO;AAAES,UAAAA,IAAF;AAAQM,UAAAA;AAAR,SAAP;AACD;;AAED,aAAO;AAAEN,QAAAA;AAAF,OAAP;AACD,KApCD,CADmC,EAsCnCtB,aAtCmC,CAArC;;AAyCA,QAAIiC,OAAJ,EAAa;AAAA;;AACX;AACA,yBAAOA,OAAP,6CAAO,SAASe,MAAT,CAAgBf,OAAO,CAACgB,KAAR,IAAiB,CAAjC,EAAoCF,KAA3C,EAAkD;AAAA;;AAChDd,QAAAA,OAAO,GAAGA,OAAO,CAACe,MAAR,CAAef,OAAO,CAACgB,KAAR,IAAiB,CAAhC,EAAmCF,KAA7C;AACD;;AAEAd,MAAAA,OAAD,CAA2Ce,MAA3C,CACE,cAAAf,OAAO,UAAP,8CAASgB,KAAT,KAAkB,CADpB,EAEEF,KAFF,GAEUA,KAFV;AAGD,KATD,MASO;AACLf,MAAAA,MAAM,GAAGe,KAAT;AACD;;AAEDd,IAAAA,OAAO,GAAGc,KAAV;AACD;;AAED,MAAId,OAAO,IAAI,IAAX,IAAmBD,MAAM,IAAI,IAAjC,EAAuC;AACrC,WAAOD,SAAP;AACD;;AAED,QAAMmB,KAAK,GAAGC,gBAAgB,CAAClB,OAAD,CAA9B;AACA,QAAML,MAAM,GAAGC,gBAAgB,CAC7B/B,IAD6B,EAE7BsD,uBAAuB,CAACF,KAAK,CAAC5B,IAAP,EAAarB,OAAb,CAFM,CAA/B;;AAKA,MAAI2B,MAAJ,EAAY;AACVsB,IAAAA,KAAK,CAACtB,MAAN,mCAAoBsB,KAAK,CAACtB,MAA1B,GAAqCA,MAArC;AACD;;AAED,SAAOI,MAAP;AACD;;AAED,MAAMqB,SAAS,GAAG,CAAC,GAAGC,KAAJ,KACf,EAAD,CACGpD,MADH,CACU,GAAGoD,KAAK,CAACjD,GAAN,CAAWiC,CAAD,IAAOA,CAAC,CAAC1B,KAAF,CAAQ,GAAR,CAAjB,CADb,EAEGyB,MAFH,CAEUkB,OAFV,EAGGT,IAHH,CAGQ,GAHR,CADF;;AAMA,MAAMvC,uBAAuB,GAAG,CAC9BiB,MAD8B,EAE9BgC,WAF8B,EAG9BpC,UAAoB,GAAG,EAHO,EAI9BqC,QAJ8B,EAK9BC,aAL8B,KAMZ;AAClB,QAAMzD,OAAsB,GAAG,EAA/B;AAEAmB,EAAAA,UAAU,CAACuC,IAAX,CAAgBnC,MAAhB;AAEA,QAAML,MAAM,GAAGqC,WAAW,CAAChC,MAAD,CAA1B;;AAEA,MAAI,OAAOL,MAAP,KAAkB,QAAtB,EAAgC;AAC9B;AACA,UAAMR,OAAO,GAAG+C,aAAa,GAAGL,SAAS,CAACK,aAAD,EAAgBvC,MAAhB,CAAZ,GAAsCA,MAAnE;AAEAlB,IAAAA,OAAO,CAAC0D,IAAR,CAAaC,gBAAgB,CAACpC,MAAD,EAASJ,UAAT,EAAqBT,OAArB,EAA8BQ,MAA9B,CAA7B;AACD,GALD,MAKO,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AACrC,QAAIR,OAAJ,CADqC,CAGrC;AACA;AACA;;AACA,QAAI,OAAOQ,MAAM,CAACrB,IAAd,KAAuB,QAA3B,EAAqC;AACnCa,MAAAA,OAAO,GACLQ,MAAM,CAAC0C,KAAP,KAAiB,IAAjB,IAAyBH,aAAzB,GACIL,SAAS,CAACK,aAAD,EAAgBvC,MAAM,CAACrB,IAAvB,CADb,GAEIqB,MAAM,CAACrB,IAHb;AAKAG,MAAAA,OAAO,CAAC0D,IAAR,CACEC,gBAAgB,CAACpC,MAAD,EAASJ,UAAT,EAAqBT,OAArB,EAA8BQ,MAAM,CAACrB,IAArC,EAA2CqB,MAAM,CAACW,KAAlD,CADlB;AAGD;;AAED,QAAIX,MAAM,CAAC2C,OAAX,EAAoB;AAClB;AACA,UAAI3C,MAAM,CAAC4C,gBAAX,EAA6B;AAC3BN,QAAAA,QAAQ,CAACE,IAAT,CAAc;AACZI,UAAAA,gBAAgB,EAAE5C,MAAM,CAAC4C,gBADb;AAEZC,UAAAA,eAAe,EAAE7D,MAAM,CAACC,IAAP,CAAYe,MAAM,CAAC2C,OAAnB;AAFL,SAAd;AAID;;AAED3D,MAAAA,MAAM,CAACC,IAAP,CAAYe,MAAM,CAAC2C,OAAnB,EAA4BG,OAA5B,CAAqCC,YAAD,IAAkB;AACpD,cAAMlC,MAAM,GAAGzB,uBAAuB,CACpC2D,YADoC,EAEpC/C,MAAM,CAAC2C,OAF6B,EAGpC1C,UAHoC,EAIpCqC,QAJoC,EAKpC9C,OALoC,CAAtC;AAQAV,QAAAA,OAAO,CAAC0D,IAAR,CAAa,GAAG3B,MAAhB;AACD,OAVD;AAWD;AACF;;AAEDZ,EAAAA,UAAU,CAAC+C,GAAX;AAEA,SAAOlE,OAAP;AACD,CA7DD;;AA+DA,MAAM2D,gBAAgB,GAAG,CACvBpC,MADuB,EAEvBJ,UAFuB,EAGvBT,OAHuB,EAIvBb,IAJuB,EAKvBgC,KALuB,KAMP;AAChB;AACAnB,EAAAA,OAAO,GAAGA,OAAO,CAACC,KAAR,CAAc,GAAd,EAAmByB,MAAnB,CAA0BkB,OAA1B,EAAmCT,IAAnC,CAAwC,GAAxC,CAAV;AAEA,QAAMX,KAAK,GAAGxB,OAAO,GACjB,IAAIyD,MAAJ,aACOzD,OAAO,CACTC,KADE,CACI,GADJ,EAEFP,GAFE,CAEGgE,EAAD,IAAQ;AACX,QAAIA,EAAE,CAAC9B,UAAH,CAAc,GAAd,CAAJ,EAAwB;AACtB,kCAAqB8B,EAAE,CAACrD,QAAH,CAAY,GAAZ,IAAmB,GAAnB,GAAyB,EAA9C;AACD;;AAED,qBAAU,iCAAOqD,EAAP,CAAV;AACD,GARE,EASFvB,IATE,CASG,EATH,CADP,OADiB,GAajBf,SAbJ;AAeA,SAAO;AACLP,IAAAA,MADK;AAELW,IAAAA,KAFK;AAGLxB,IAAAA,OAHK;AAILb,IAAAA,IAJK;AAKL;AACAsB,IAAAA,UAAU,EAAE,CAAC,GAAGA,UAAJ,CANP;AAOLU,IAAAA;AAPK,GAAP;AASD,CAlCD;;AAoCA,MAAMsB,uBAAuB,GAAG,CAC9BkB,SAD8B,EAE9BC,UAF8B,KAGF;AAC5B,OAAK,MAAMpD,MAAX,IAAqBoD,UAArB,EAAiC;AAC/B,QAAID,SAAS,KAAKnD,MAAM,CAACC,UAAP,CAAkBD,MAAM,CAACC,UAAP,CAAkBP,MAAlB,GAA2B,CAA7C,CAAlB,EAAmE;AACjE,aAAOM,MAAM,CAACW,KAAd;AACD;AACF;;AAED,SAAOC,SAAP;AACD,CAXD,C,CAaA;;;AACA,MAAMyC,gBAAgB,GAAG,CACvBF,SADuB,EAEvBtE,aAFuB,KAGA;AACvB,OAAK,MAAMmB,MAAX,IAAqBnB,aAArB,EAAoC;AAClC,QAAImB,MAAM,CAAC6C,eAAP,CAAuBS,QAAvB,CAAgCH,SAAhC,CAAJ,EAAgD;AAC9C,aAAOnD,MAAM,CAAC4C,gBAAP,KAA4BO,SAA5B,GACHvC,SADG,GAEHZ,MAAM,CAAC4C,gBAFX;AAGD;AACF;;AACD,SAAOhC,SAAP;AACD,CAZD,C,CAcA;AACA;;;AACA,MAAM2C,iBAAiB,GAAG,CACxBC,YADwB,EAExBL,SAFwB,EAGxB1C,MAHwB,EAIxBgD,OAJwB,KAKP;AACjB,MAAIA,OAAJ,EAAa;AACX,QAAID,YAAJ,EAAkB;AAChB,aAAO;AACL1B,QAAAA,KAAK,EAAE,CADF;AAELD,QAAAA,MAAM,EAAE,CAAC;AAAE1B,UAAAA,IAAI,EAAEqD;AAAR,SAAD,EAAyB;AAAErD,UAAAA,IAAI,EAAEgD,SAAR;AAA6B1C,UAAAA;AAA7B,SAAzB;AAFH,OAAP;AAID,KALD,MAKO;AACL,aAAO;AACLoB,QAAAA,MAAM,EAAE,CAAC;AAAE1B,UAAAA,IAAI,EAAEgD,SAAR;AAA6B1C,UAAAA;AAA7B,SAAD;AADH,OAAP;AAGD;AACF,GAXD,MAWO;AACL,QAAI+C,YAAJ,EAAkB;AAChB,aAAO;AACL1B,QAAAA,KAAK,EAAE,CADF;AAELD,QAAAA,MAAM,EAAE,CACN;AAAE1B,UAAAA,IAAI,EAAEqD;AAAR,SADM,EAEN;AAAErD,UAAAA,IAAI,EAAEgD,SAAR;AAA6B1C,UAAAA,MAA7B;AAAqCmB,UAAAA,KAAK,EAAE;AAAEC,YAAAA,MAAM,EAAE;AAAV;AAA5C,SAFM;AAFH,OAAP;AAOD,KARD,MAQO;AACL,aAAO;AACLA,QAAAA,MAAM,EAAE,CAAC;AAAE1B,UAAAA,IAAI,EAAEgD,SAAR;AAA6B1C,UAAAA,MAA7B;AAAqCmB,UAAAA,KAAK,EAAE;AAAEC,YAAAA,MAAM,EAAE;AAAV;AAA5C,SAAD;AADH,OAAP;AAGD;AACF;AACF,CAhCD;;AAkCA,MAAMvB,uBAAuB,GAAG,CAC9BuB,MAD8B,EAE9BhD,aAF8B,KAG3B;AACH,MAAI+C,KAAJ;AACA,MAAIG,KAAK,GAAGF,MAAM,CAACH,KAAP,EAAZ;AACA,MAAI8B,YAAY,GAAGH,gBAAgB,CAACtB,KAAK,CAAC5B,IAAP,EAAatB,aAAb,CAAnC;AAEA+C,EAAAA,KAAK,GAAG2B,iBAAiB,CACvBC,YADuB,EAEvBzB,KAAK,CAAC5B,IAFiB,EAGvB4B,KAAK,CAACtB,MAHiB,EAIvBoB,MAAM,CAACnC,MAAP,KAAkB,CAJK,CAAzB;;AAOA,MAAImC,MAAM,CAACnC,MAAP,GAAgB,CAApB,EAAuB;AACrB,QAAIgE,WAAW,GAAG9B,KAAlB;;AAEA,WAAQG,KAAK,GAAGF,MAAM,CAACH,KAAP,EAAhB,EAAsE;AACpE8B,MAAAA,YAAY,GAAGH,gBAAgB,CAACtB,KAAK,CAAC5B,IAAP,EAAatB,aAAb,CAA/B;AAEA,YAAM8E,gBAAgB,GACpBD,WAAW,CAAC5B,KAAZ,IAAqB4B,WAAW,CAAC7B,MAAZ,CAAmBnC,MAAnB,GAA4B,CADnD;AAGAgE,MAAAA,WAAW,CAAC7B,MAAZ,CAAmB8B,gBAAnB,EAAqC/B,KAArC,GAA6C2B,iBAAiB,CAC5DC,YAD4D,EAE5DzB,KAAK,CAAC5B,IAFsD,EAG5D4B,KAAK,CAACtB,MAHsD,EAI5DoB,MAAM,CAACnC,MAAP,KAAkB,CAJ0C,CAA9D;;AAOA,UAAImC,MAAM,CAACnC,MAAP,GAAgB,CAApB,EAAuB;AACrBgE,QAAAA,WAAW,GAAGA,WAAW,CAAC7B,MAAZ,CAAmB8B,gBAAnB,EACX/B,KADH;AAED;AACF;AACF;;AAED,SAAOA,KAAP;AACD,CAvCD;;AAyCA,MAAMI,gBAAgB,GAAIJ,KAAD,IAAyB;AAAA;;AAChD,MAAId,OAAiC,GAAGc,KAAxC;;AAEA,sBAAOd,OAAP,8CAAO,UAASe,MAAT,CAAgBf,OAAO,CAACgB,KAAR,IAAiB,CAAjC,EAAoCF,KAA3C,EAAkD;AAAA;;AAChD;AACAd,IAAAA,OAAO,GAAGA,OAAO,CAACe,MAAR,CAAef,OAAO,CAACgB,KAAR,IAAiB,CAAhC,EAAmCF,KAA7C;AACD;;AAED,QAAMG,KAAK,GAAIjB,OAAD,CAA2Ce,MAA3C,CACZ,cAAAf,OAAO,UAAP,8CAASgB,KAAT,KAAkB,CADN,CAAd;AAIA,SAAOC,KAAP;AACD,CAbD;;AAeA,MAAMrB,gBAAgB,GAAG,CACvB/B,IADuB,EAEvBiF,WAFuB,KAGpB;AACH,QAAMC,KAAK,GAAGlF,IAAI,CAACc,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAd;;AACA,QAAMgB,MAAM,GAAGqD,qBAAYnD,KAAZ,CAAkBkD,KAAlB,CAAf;;AAEA,MAAID,WAAJ,EAAiB;AACf5E,IAAAA,MAAM,CAACC,IAAP,CAAYwB,MAAZ,EAAoBqC,OAApB,CAA6B3C,IAAD,IAAU;AACpC,UAAIyD,WAAW,CAACzD,IAAD,CAAX,IAAqB,OAAOM,MAAM,CAACN,IAAD,CAAb,KAAwB,QAAjD,EAA2D;AACzDM,QAAAA,MAAM,CAACN,IAAD,CAAN,GAAeyD,WAAW,CAACzD,IAAD,CAAX,CAAkBM,MAAM,CAACN,IAAD,CAAxB,CAAf;AACD;AACF,KAJD;AAKD;;AAED,SAAOnB,MAAM,CAACC,IAAP,CAAYwB,MAAZ,EAAoBf,MAApB,GAA6Be,MAA7B,GAAsCG,SAA7C;AACD,CAhBD","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\nimport { PathConfig } from './types';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: PathConfig = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(options).map((key) =>\n        createNormalizedConfigs(key, options, [], initialRoutes)\n      )\n    )\n    .sort(\n      (a, b) =>\n        // Sort configs so the most exhaustive is always first to be chosen\n        b.pattern.split('/').length - a.pattern.split('/').length\n    );\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.path === '' &&\n        config.routeNames.every(\n          // Make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.path\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames.map((name, i, self) => {\n          if (i === self.length - 1) {\n            return { name, params: parseQueryParams(path, match.parse) };\n          }\n\n          return { name };\n        }),\n        initialRoutes\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let allParams: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      if (!config.regex) {\n        continue;\n      }\n\n      const match = remaining.match(config.regex);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          allParams = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const value = match![(i + 1) * 2].replace(/\\//, ''); // The param segments appear every second item starting from 2 in the regex match result\n\n            acc[p] = value;\n\n            return acc;\n          }, {});\n        }\n\n        remaining = remaining.replace(match[1], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(\n      routeNames.map((name) => {\n        const config = configs.find((c) => c.screen === name);\n\n        let params: object | undefined;\n\n        if (allParams && config?.path) {\n          const pattern = config.path;\n\n          if (pattern) {\n            const paramPatterns = pattern\n              .split('/')\n              .filter((p) => p.startsWith(':'));\n\n            if (paramPatterns.length) {\n              params = paramPatterns.reduce<Record<string, any>>((acc, p) => {\n                const key = p.replace(/^:/, '').replace(/\\?$/, '');\n                const value = allParams![p];\n\n                if (value) {\n                  acc[key] =\n                    config.parse && config.parse[key]\n                      ? config.parse[key](value)\n                      : value;\n                }\n\n                return acc;\n              }, {});\n            }\n          }\n        }\n\n        if (params && Object.keys(params).length) {\n          return { name, params };\n        }\n\n        return { name };\n      }),\n      initialRoutes\n    );\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfig,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      pattern =\n        config.exact !== true && parentPattern\n          ? joinPaths(parentPattern, config.path)\n          : config.path;\n\n      configs.push(\n        createConfigItem(screen, routeNames, pattern, config.path, config.parse)\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          connectedRoutes: Object.keys(config.screens),\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfig,\n          routeNames,\n          initials,\n          pattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  parse?: ParseConfig\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  routeName: string,\n  params: Record<string, any> | undefined,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { name: routeName as string, params }],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, params, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  routes: { name: string; params?: object }[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let state: InitialState;\n  let route = routes.shift() as { name: string; params?: object };\n  let initialRoute = findInitialRoute(route.name, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    route.name,\n    route.params,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as { name: string; params?: object })) {\n      initialRoute = findInitialRoute(route.name, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route.name,\n        route.params,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n};\n\nconst findFocusedRoute = (state: InitialState) => {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) => {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"]}