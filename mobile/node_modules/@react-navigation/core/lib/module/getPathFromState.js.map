{"version":3,"sources":["getPathFromState.tsx"],"names":["queryString","getPathFromState","state","options","undefined","Error","configs","createNormalizedConfigs","path","current","allParams","index","route","routes","pattern","currentParams","params","currentOptions","nestedRouteNames","hasNext","name","push","stringify","fromEntries","Object","entries","map","key","value","String","assign","screens","length","nextRoute","nestedConfig","join","split","p","replace","startsWith","endsWith","encodeURIComponent","param","query","reduce","acc","k","v","joinPaths","paths","concat","filter","Boolean","createConfigItem","config","parentPattern","exact","c","result"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport { PathConfig } from './types';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype OptionsItem = PathConfig[string];\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state?: State,\n  options: PathConfig = {}\n): string {\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n\n  // Create a normalized configs array which will be easier to use\n  const configs = createNormalizedConfigs(options);\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let currentParams: Record<string, any> = { ...route.params };\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = p.replace(/^:/, '').replace(/\\?$/, '');\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            // Remove the used value from the params object since we'll use the rest for query string\n            if (currentParams) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete currentParams[name];\n            }\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (currentParams) {\n      for (let param in currentParams) {\n        if (currentParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete currentParams[param];\n        }\n      }\n\n      const query = queryString.stringify(currentParams);\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\n// Object.fromEntries is not available in older iOS versions\nconst fromEntries = <K extends string, V>(entries: (readonly [K, V])[]) =>\n  entries.reduce((acc, [k, v]) => {\n    acc[k] = v;\n    return acc;\n  }, {} as Record<K, V>);\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: OptionsItem | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true && parentPattern && config.path\n      ? joinPaths(parentPattern, config.path)\n      : config.path;\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfig,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n"]}